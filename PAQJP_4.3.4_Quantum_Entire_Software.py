exec("""\nv='%0*x'\no='.jpeg'\nn='rb'\nm='wb'\nl=input\nk=bin\nj=str\nf='.txt'\ne='.jpg'\nd='utf-8'\nc=ValueError\nY=False\nX=True\nV=print\nT='Insufficient data for reverse transformation (missing date bytes)'\nS='1'\nR='0'\nQ=max\nP=min\nN=''\nM=open\nK=Exception\nH=b''\nG=bytes\nF=bytearray\nE=int\nD=range\nC=None\nA=len\nimport os as I,sys,math as g,struct,array,random as U,heapq as Z,binascii as W,logging as B,paq,zlib as a\nfrom datetime import datetime as b\nfrom typing import List,Dict,Tuple,Optional,Union\nfrom enum import Enum as p\nfrom mpmath import mp\nB.basicConfig(level=B.INFO,format='%(asctime)s - %(levelname)s - %(message)s')\nA6='PAQJP_4'\nA7=9\nA8=1<<15\nw=1024\nh='pi_digits.txt'\ni=[A for A in D(2,256)if all(A%B!=0 for B in D(2,E(A**.5)+1))]\ndef q(digits,filename=h):\n	D=digits;C=filename\n	try:\n		with M(C,'w')as E:E.write(','.join(j(A)for A in D))\n		B.info(f"Successfully saved {A(D)} base-10 pi digits to {C}");return X\n	except K as F:B.error(f"Failed to save base-10 pi digits to {C}: {F}");return Y\ndef x(filename=h,expected_count=3):\n	H=expected_count;C=filename\n	try:\n		if not I.path.isfile(C):B.warning(f"Base-10 pi digits file {C} does not exist");return\n		with M(C,'r')as L:\n			J=L.read().strip()\n			if not J:B.warning(f"Base-10 pi digits file {C} is empty");return\n			D=[]\n			for F in J.split(','):\n				if not F.isdigit():B.warning(f"Invalid integer in {C}: {F}");return\n				G=E(F)\n				if not 0<=G<=255:B.warning(f"Digit out of range in {C}: {G}");return\n				D.append(G)\n			if A(D)!=H:B.warning(f"Loaded {A(D)} digits, expected {H}");return\n			B.info(f"Successfully loaded {A(D)} base-10 pi digits from {C}");return D\n	except K as N:B.error(f"Failed to load base-10 pi digits from {C}: {N}");return\ndef y(num_digits=3,filename=h):\n	G=filename;D=num_digits;I=x(G,D)\n	if I is not C:return I\n	try:\n		mp.dps=D;F=[E(A)for A in mp.pi.digits(10)[0]]\n		if A(F)!=D:B.error(f"Generated {A(F)} digits, expected {D}");raise c('Incorrect number of pi digits generated')\n		if not all(0<=A<=9 for A in F):B.error('Generated pi digits contain invalid values');raise c('Invalid pi digits generated')\n		J=[A*255//9%256 for A in F];q(J,G);return J\n	except K as L:B.error(f"Failed to generate base-10 pi digits: {L}");M=[3,1,4];H=[A*255//9%256 for A in M[:D]];B.warning(f"Using {A(H)} fallback base-10 digits");q(H,G);return H\nz=y(3)\nclass O(p):DEFAULT=0;JPEG=1;EXE=2;TEXT=3\nclass A9(p):COMPRESS=0;DECOMPRESS=1\nclass AA:\n	def __init__(A,s=N):A.data=F(s.encode(d))\n	def resize(B,new_size):\n		C=new_size\n		if C>A(B.data):B.data+=F(C-A(B.data))\n		else:B.data=B.data[:C]\n	def size(B):return A(B.data)\n	def c_str(A):return A.data.decode(d)\n	def __iadd__(A,s):A.data+=s.encode(d);return A\n	def __getitem__(A,index):return A.data[index]\n	def __setitem__(A,index,value):A.data[index]=value\n	def __str__(A):return A.data.decode(d)\nclass r:\n	def __init__(A,size=0,initial_value=0):A.data=array.array('B',[initial_value]*size)\n	def resize(B,new_size):\n		C=new_size\n		if C>A(B.data):B.data.extend([0]*(C-A(B.data)))\n		else:B.data=B.data[:C]\n	def size(B):return A(B.data)\n	def __getitem__(A,index):return A.data[index]\n	def __setitem__(A,index,value):A.data[index]=value\n	def __len__(B):return A(B.data)\nclass A0:\n	def __init__(A,size=0):A.size_=size;A.data=r(size);A.pos=0\n	def setsize(B,size):\n		A=size\n		if A>0 and A&A-1==0:B.size_=A;B.data.resize(A)\n	def __getitem__(A,index):return A.data[index&A.size_-1]\n	def __call__(A,i):return A.data[A.pos-i&A.size_-1]\n	def size(A):return A.size_\nAB=A0()\nclass s:\n	def __init__(A,left=C,right=C,symbol=C):A.left=left;A.right=right;A.symbol=symbol\n	def is_leaf(A):return A.left is C and A.right is C\nclass A1:\n	def __init__(A):A.table=[[1,2,0,0],[3,5,1,0],[4,6,0,1],[7,10,2,0],[8,12,1,1],[9,13,1,1],[11,14,0,2],[15,19,3,0],[16,23,2,1],[17,24,2,1],[18,25,2,1],[20,27,1,2],[21,28,1,2],[22,29,1,2],[26,30,0,3],[31,33,4,0],[32,35,3,1],[32,35,3,1],[32,35,3,1],[32,35,3,1],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[36,39,1,3],[36,39,1,3],[36,39,1,3],[36,39,1,3],[38,40,0,4],[41,43,5,0],[42,45,4,1],[42,45,4,1],[44,47,3,2],[44,47,3,2],[46,49,2,3],[46,49,2,3],[48,51,1,4],[48,51,1,4],[50,52,0,5],[53,43,6,0],[54,57,5,1],[54,57,5,1],[56,59,4,2],[56,59,4,2],[58,61,3,3],[58,61,3,3],[60,63,2,4],[60,63,2,4],[62,65,1,5],[62,65,1,5],[50,66,0,6],[67,55,7,0],[68,57,6,1],[68,57,6,1],[70,73,5,2],[70,73,5,2],[72,75,4,3],[72,75,4,3],[74,77,3,4],[74,77,3,4],[76,79,2,5],[76,79,2,5],[62,81,1,6],[62,81,1,6],[64,82,0,7],[83,69,8,0],[84,76,7,1],[84,76,7,1],[86,73,6,2],[86,73,6,2],[44,59,5,3],[44,59,5,3],[58,61,4,4],[58,61,4,4],[60,49,3,5],[60,49,3,5],[76,89,2,6],[76,89,2,6],[78,91,1,7],[78,91,1,7],[80,92,0,8],[93,69,9,0],[94,87,8,1],[94,87,8,1],[96,45,7,2],[96,45,7,2],[48,99,2,7],[48,99,2,7],[88,101,1,8],[88,101,1,8],[80,102,0,9],[103,69,10,0],[104,87,9,1],[104,87,9,1],[106,57,8,2],[106,57,8,2],[62,109,2,8],[62,109,2,8],[88,111,1,9],[88,111,1,9],[80,112,0,10],[113,85,11,0],[114,87,10,1],[114,87,10,1],[116,57,9,2],[116,57,9,2],[62,119,2,9],[62,119,2,9],[88,121,1,10],[88,121,1,10],[90,122,0,11],[123,85,12,0],[124,97,11,1],[124,97,11,1],[126,57,10,2],[126,57,10,2],[62,129,2,10],[62,129,2,10],[98,131,1,11],[98,131,1,11],[90,132,0,12],[133,85,13,0],[134,97,12,1],[134,97,12,1],[136,57,11,2],[136,57,11,2],[62,139,2,11],[62,139,2,11],[98,141,1,12],[98,141,1,12],[90,142,0,13],[143,95,14,0],[144,97,13,1],[144,97,13,1],[68,57,12,2],[68,57,12,2],[62,81,2,12],[62,81,2,12],[98,147,1,13],[98,147,1,13],[100,148,0,14],[149,95,15,0],[150,107,14,1],[150,107,14,1],[108,151,1,14],[108,151,1,14],[100,152,0,15],[153,95,16,0],[154,107,15,1],[108,155,1,15],[100,156,0,16],[157,95,17,0],[158,107,16,1],[108,159,1,16],[100,160,0,17],[161,105,18,0],[162,107,17,1],[108,163,1,17],[110,164,0,18],[165,105,19,0],[166,117,18,1],[118,167,1,18],[110,168,0,19],[169,105,20,0],[170,117,19,1],[118,171,1,19],[110,172,0,20],[173,105,21,0],[174,117,20,1],[118,175,1,20],[110,176,0,21],[177,105,22,0],[178,117,21,1],[118,179,1,21],[120,184,0,23],[185,115,24,0],[186,127,23,1],[128,187,1,23],[120,188,0,24],[189,115,25,0],[190,127,24,1],[128,191,1,24],[120,192,0,25],[193,115,26,0],[194,127,25,1],[128,195,1,25],[120,196,0,26],[197,115,27,0],[198,127,26,1],[128,199,1,26],[120,200,0,27],[201,115,28,0],[202,127,27,1],[128,203,1,27],[120,204,0,28],[205,115,29,0],[206,127,28,1],[128,207,1,28],[120,208,0,29],[209,125,30,0],[210,127,29,1],[128,211,1,29],[130,212,0,30],[213,125,31,0],[214,137,30,1],[138,215,1,30],[130,216,0,31],[217,125,32,0],[218,137,31,1],[138,219,1,31],[130,220,0,32],[221,125,33,0],[222,137,32,1],[138,223,1,32],[130,224,0,33],[225,125,34,0],[226,137,33,1],[138,227,1,33],[130,228,0,34],[229,125,35,0],[230,137,34,1],[138,231,1,34],[130,232,0,35],[233,125,36,0],[234,137,35,1],[138,235,1,35],[130,236,0,36],[237,125,37,0],[238,137,36,1],[138,239,1,36],[130,240,0,37],[241,125,38,0],[242,137,37,1],[138,243,1,37],[130,244,0,38],[245,135,39,0],[246,137,38,1],[138,247,1,38],[140,248,0,39],[249,135,40,0],[250,69,39,1],[80,251,1,39],[140,252,0,40],[249,135,41,0],[250,69,40,1],[80,251,1,40],[140,252,0,41]]\n	def nex(A,state,sel):return A.table[state][sel]\nAC=A1()\ndef J(dt=C):\n	if dt is C:B.warning('No datetime provided, using current time as fallback. Should use file creation time.');dt=b.now()\n	A=E(dt.timestamp());F=2**40-1;H=P(A,F);return G([H>>A*8&255 for A in D(4,-1,-1)])\ndef L(data):\n	if A(data)!=5:B.error('Insufficient data for datetime decoding');raise c('Data must be 5 bytes')\n	C=sum(data[A]<<8*(4-A)for A in D(5));E=P(C,2**40-1);return b.fromtimestamp(E)\ndef AD(data,creation_time=C):\n	B=F(data)\n	for C in i:\n		E=C if C==2 else Q(1,g.ceil(C*4096/28672))\n		for K in D(7):\n			for H in D(0,A(B),3):B[H]^=E\n	I=J(creation_time);return I+G(B)\ndef AE(data,creation_time=C):\n	B=F()\n	for C in D(0,A(data),4):E=data[C:C+4];B.extend([A^255 for A in E])\n	H=J(creation_time);return H+G(B)\ndef t(n):\n	if n<2:return Y\n	if n==2:return X\n	if n%2==0:return Y\n	for A in D(3,E(n**.5)+1,2):\n		if n%A==0:return Y\n	return X\ndef u(n):\n	A=0\n	while X:\n		if t(n-A):return n-A\n		if t(n+A):return n+A\n		A+=1\ndef quit(message=C):\n	A=message\n	if A:V(A)\n	sys.exit(1)\ndef AF(x):\n	if x<0:return 0\n	A=0\n	while x>0:x>>=1;A+=1\n	return A\ndef A2(d,n=12,repeat=1000):\n	B=(1<<n)-1;A=d\n	for F in D(repeat):\n		if A>2047:A=B\n		if A<-2047:A=0\n		C=(1<<n)/(1+g.exp(-A/512.));A=E(C);A=P(Q(A,0),B)\n	return A\ndef AG(p):\n	A=r(4096);B=0\n	for C in D(-2047,2048):\n		E=A2(C)\n		for F in D(B,E+1):A[F]=C\n		B=E+1\n	A[4095]=2047;return A[p]\ndef hash(*B):C=B[0]*200002979+B[1]*30005491+(B[2]if A(B)>2 else 4294967295)*50004239+(B[3]if A(B)>3 else 4294967295)*70004807+(B[4]if A(B)>4 else 4294967295)*110002499;return C^C>>9^B[0]>>2^B[1]>>3^(B[2]if A(B)>2 else 0)>>4^(B[3]if A(B)>3 else 0)>>5^(B[4]if A(B)>4 else 0)>>6\nclass A3:\n	def __init__(A):A.compressor=C;A.PRIMES=i;A.PI_DIGITS=z;A.seed_tables=A.generate_seed_tables();A.max_intersections=28\n	def generate_seed_tables(C,num_tables=126,table_size=256,min_val=5,max_val=255,seed=42):\n		U.seed(seed);A=[]\n		for E in D(num_tables):B=[U.randint(min_val,max_val)for A in D(table_size)];A.append(B)\n		return A\n	def get_seed(B,table_idx,value):\n		C=table_idx\n		if 0<=C<A(B.seed_tables):return B.seed_tables[C][value%A(B.seed_tables[C])]\n		return 0\n	def binary_to_file(L,binary_data,filename):\n		D=binary_data\n		try:\n			F=E(D,2);G=(A(D)+7)//8;C=v%(G*2,F)\n			if A(C)%2!=0:C=R+C\n			H=W.unhexlify(C)\n			with M(filename,m)as I:I.write(H)\n			return X\n		except K as J:B.error(f"Error saving file: {j(J)}");return Y\n	def file_to_binary(H,filename):\n		try:\n			with M(filename,n)as D:\n				C=D.read()\n				if not C:B.error('Error: Empty file');return\n				F=k(E(W.hexlify(C),16))[2:];return F.zfill(A(C)*8)\n		except K as G:B.error(f"Error reading file: {j(G)}");return\n	def calculate_frequencies(C,binary_str):\n		A={}\n		for B in binary_str:A[B]=A.get(B,0)+1\n		return A\n	def build_huffman_tree(H,frequencies):\n		B=[(B,s(symbol=A))for(A,B)in frequencies.items()];Z.heapify(B)\n		while A(B)>1:C,D=Z.heappop(B);E,F=Z.heappop(B);G=s(left=D,right=F);Z.heappush(B,(C+E,G))\n		return B[0][1]\n	def generate_huffman_codes(D,root,current_code=N,codes={}):\n		C=current_code;B=codes;A=root\n		if A.is_leaf():B[A.symbol]=C or R;return B\n		if A.left:D.generate_huffman_codes(A.left,C+R,B)\n		if A.right:D.generate_huffman_codes(A.right,C+S,B)\n		return B\n	def compress_data_huffman(B,binary_str):\n		C=binary_str\n		if not C:return N\n		D=B.calculate_frequencies(C);E=B.build_huffman_tree(D);A=B.generate_huffman_codes(E)\n		if R not in A:A[R]=R\n		if S not in A:A[S]=S\n		F=N.join(A[B]for B in C);return F\n	def decompress_data_huffman(B,compressed_str):\n		C=compressed_str\n		if not C:return N\n		F=B.calculate_frequencies(C);G=B.build_huffman_tree(F);H=B.generate_huffman_codes(G);D={B:A for(A,B)in H.items()};E=N;A=N\n		for I in C:\n			A+=I\n			if A in D:E+=D[A];A=N\n		return E\n	def compress_data_zlib(C,data_bytes):\n		try:return a.compress(data_bytes)\n		except a.error as A:B.error(f"zlib compression error: {A}");return\n	def decompress_data_zlib(C,compressed_data):\n		try:return a.decompress(compressed_data)\n		except a.error as A:B.error(f"zlib decompression error: {A}");return\n	def transform_01(K,data,creation_time=C):\n		B=F(data)\n		for C in i:\n			E=C if C==2 else Q(1,g.ceil(C*4096/28672))\n			for L in D(7):\n				for H in D(0,A(B),3):B[H]^=E\n		I=J(creation_time);return I+G(B)\n	def reverse_transform_01(I,data):\n		D=data\n		if A(D)<5:B.error(T);return H,C\n		E=D[:5];F=L(E);G=D[5:];return G,F\n	def transform_03(I,data,creation_time=C):\n		B=F()\n		for C in D(0,A(data),4):E=data[C:C+4];B.extend([A^255 for A in E])\n		H=J(creation_time);return H+G(B)\n	def reverse_transform_03(I,data):\n		D=data\n		if A(D)<5:B.error(T);return H,C\n		E=D[:5];F=L(E);G=D[5:];return G,F\n	def transform_04(H,data,creation_time=C,repeat=50):\n		B=F(data)\n		for I in D(repeat):\n			for C in D(A(B)):B[C]=(B[C]-C%256)%256\n		E=J(creation_time);return E+G(B)\n	def reverse_transform_04(N,data):\n		I=data\n		if A(I)<5:B.error(T);return H,C\n		K=I[:5];M=L(K);E=F(I[5:])\n		for O in D(50):\n			for J in D(A(E)):E[J]=(E[J]+J%256)%256\n		return G(E),M\n	def transform_05(I,data,creation_time=C,shift=3):\n		E=shift;B=F(data)\n		for C in D(A(B)):B[C]=(B[C]<<E|B[C]>>8-E)&255\n		H=J(creation_time);return H+G(B)\n	def reverse_transform_05(O,data,shift=3):\n		K=shift;I=data\n		if A(I)<5:B.error(T);return H,C\n		M=I[:5];N=L(M);E=F(I[5:])\n		for J in D(A(E)):E[J]=(E[J]>>K|E[J]<<8-K)&255\n		return G(E),N\n	def transform_06(I,data,creation_time=C,seed=42):\n		U.seed(seed);C=list(D(256));U.shuffle(C);B=F(data)\n		for E in D(A(B)):B[E]=C[B[E]]\n		H=J(creation_time);return H+G(B)\n	def reverse_transform_06(Q,data):\n		J=data\n		if A(J)<5:B.error(T);return H,C\n		O=J[:5];K=L(O);E=F(J[5:])\n		if not E:B.error('Transformed data is empty after date extraction');return H,K\n		U.seed(42);M=list(D(256));U.shuffle(M);N=[0]*256\n		for(I,P)in enumerate(M):N[P]=I\n		for I in D(A(E)):\n			if E[I]>=256:B.error(f"Invalid byte value at index {I}: {E[I]}");return H,K\n			E[I]=N[E[I]]\n		return G(E),K\n	def transform_07(C,data,creation_time=C):\n		H=data;I=F(H);L=A(C.PI_DIGITS);O=A(H)/1024;M=P(10,Q(1,E(O)));B.info(f"transform_07: Using {M} cycles for {A(H)} bytes (base-256)");N=A(H)%L;C.PI_DIGITS=C.PI_DIGITS[N:]+C.PI_DIGITS[:N];R=A(H)%256\n		for K in D(A(I)):I[K]^=R\n		for U in D(M):\n			for K in D(A(I)):S=C.PI_DIGITS[K%L];I[K]^=S\n		T=J(creation_time);return T+G(I)\n	def reverse_transform_07(J,data):\n		M=data\n		if A(M)<5:B.error(T);return H,C\n		S=M[:5];U=L(S);I=F(M[5:]);N=A(J.PI_DIGITS);V=A(I)/1024;O=P(10,Q(1,E(V)));B.info(f"reverse_transform_07: Using {O} cycles for {A(I)} bytes (base-256)")\n		for Y in D(O):\n			for K in D(A(I)):W=J.PI_DIGITS[K%N];I[K]^=W\n		X=A(I)%256\n		for K in D(A(I)):I[K]^=X\n		R=A(I)%N;J.PI_DIGITS=J.PI_DIGITS[-R:]+J.PI_DIGITS[:-R];return G(I),U\n	def transform_08(C,data,creation_time=C):\n		H=data;I=F(H);L=A(C.PI_DIGITS);O=A(H)/1024;M=P(10,Q(1,E(O)));B.info(f"transform_08: Using {M} cycles for {A(H)} bytes (base-256)");N=A(H)%L;C.PI_DIGITS=C.PI_DIGITS[N:]+C.PI_DIGITS[:N];R=u(A(H)%256)\n		for K in D(A(I)):I[K]^=R\n		for U in D(M):\n			for K in D(A(I)):S=C.PI_DIGITS[K%L];I[K]^=S\n		T=J(creation_time);return T+G(I)\n	def reverse_transform_08(J,data):\n		M=data\n		if A(M)<5:B.error(T);return H,C\n		S=M[:5];U=L(S);I=F(M[5:]);N=A(J.PI_DIGITS);V=A(I)/1024;O=P(10,Q(1,E(V)));B.info(f"reverse_transform_08: Using {O} cycles for {A(I)} bytes (base-256)")\n		for Y in D(O):\n			for K in D(A(I)):W=J.PI_DIGITS[K%N];I[K]^=W\n		X=u(A(I)%256)\n		for K in D(A(I)):I[K]^=X\n		R=A(I)%N;J.PI_DIGITS=J.PI_DIGITS[-R:]+J.PI_DIGITS[:-R];return G(I),U\n	def paq_compress(A,data):return paq.compress(data)\n	def paq_decompress(A,data):return paq.decompress(data)\n	def compress_with_best_method(D,data,filetype,input_file):\n		T=input_file;S=filetype;F=data\n		try:U=b.fromtimestamp(I.stat(T).st_ctime)\n		except(OSError,AttributeError)as M:B.warning(f"Failed to get creation time from {T}: {M}. Using current time as fallback.");U=b.now()\n		N=[(1,D.transform_01),(2,D.transform_03),(3,D.transform_04),(4,D.transform_05),(5,D.transform_06),(6,D.transform_07),(7,D.transform_08)]\n		if S in[O.JPEG,O.TEXT]:N=[(6,D.transform_07),(7,D.transform_08)]+N\n		a=[('paq',D.paq_compress),('zlib',D.compress_data_zlib)];H=C;J=float('inf');L=C;P=C\n		for(V,c)in N:\n			d=c(F,U)\n			for(X,e)in a:\n				try:\n					Q=e(d)\n					if Q is C:continue\n					Y=A(Q)\n					if Y<J:J=Y;H=Q;L=V;P=X\n				except K as M:B.warning(f"Compression method {X} with transform {V} failed: {M}");continue\n		if A(F)<w:\n			f=k(E(W.hexlify(F),16))[2:].zfill(A(F)*8);Z=D.compress_data_huffman(f);R=E(Z,2).to_bytes((A(Z)+7)//8,'big')\n			if A(R)<J:J=A(R);H=R;L=4;P='huffman'\n		if H is C:B.error('All compression methods failed.');return\n		B.info(f"Best compression method: {P}, Marker: {L} for {S.name}");return G([L])+H\n	def decompress_with_best_method(D,data):\n		O=data\n		if A(O)<1:B.error('Empty or insufficient compressed data.');return H,C\n		F=O[0];I=O[1:];P={1:D.reverse_transform_01,2:D.reverse_transform_03,3:D.reverse_transform_04,4:D.reverse_transform_05,5:D.reverse_transform_06,6:D.reverse_transform_07,7:D.reverse_transform_08}\n		if F==4:\n			U=k(E(W.hexlify(I),16))[2:].zfill(A(I)*8);Q=D.decompress_data_huffman(U)\n			if not Q:B.error('Huffman decompression failed.');return H,C\n			try:\n				V=(A(Q)+7)//8;J=v%(V*2,E(Q,2))\n				if A(J)%2!=0:J=R+J\n				M=W.unhexlify(J)\n				if A(M)<5:B.error('Decompressed data too short to extract date');return M,C\n				X=M[:5];G=L(X);return M[5:],G\n			except K as S:B.error(f"Error converting decompressed Huffman data: {S}");return H,C\n		if F not in P:B.error(f"Unknown compression method marker: {F}");raise c(f"Unknown compression method marker: {F}")\n		try:N=D.paq_decompress(I);T,G=P[F](N);return T,G\n		except K as S:B.warning(f"PAQ decompression failed: {S}. Trying zlib...")\n		N=D.decompress_data_zlib(I)\n		if N is C:B.error('All decompression methods failed.');return H,C\n		T,G=P[F](N);return T,G\ndef A4(filename):\n	B,A=I.path.splitext(filename.lower())\n	if A==e or A==o:return O.JPEG\n	elif A==f:return O.TEXT\n	else:return O.DEFAULT\ndef A5():\n	V('PAQJP_4 Compression System with Base-10 Pi Transformation (3 digits)');V('Created by Jurijus Pacalovas.');V('Options:');V('1 - Compress file (PAQJP_4 with transformations and creation date)');V('2 - Decompress file (PAQJP_4 with transformations and creation date)');T=A3()\n	try:\n		H=l('Enter 1 or 2: ').strip()\n		if H not in(S,'2'):B.error('Invalid choice. Exiting.');return\n	except EOFError:B.info('No input detected. Defaulting to Compress (1).');H=S\n	D=l('Input file name: ').strip()\n	if not D:B.error('No input file name provided.');return\n	E=l('Output file name: ').strip()\n	if not E:B.error('No output file name provided.');return\n	if not I.path.isfile(D):B.error(f"Error: Input file '{D}' does not exist.");return\n	J=A4(D);B.info(f"Detected filetype: {J.name}")\n	if H==S:\n		with M(D,n)as L:\n			F=L.read()\n			if not F:B.error(f"Input file '{D}' is empty.");return\n		N=T.compress_with_best_method(F,J,D)\n		if N is C:return\n		with M(E,m)as P:P.write(N)\n		Q=I.path.getsize(D);G=A(N);X=G/Q*100 if Q>0 else 0;B.info(f"Compression successful. Output saved to {E}. Size: {G} bytes");B.info(f"Original: {Q} bytes, Compressed: {G} bytes, Ratio: {X:.2f}%")\n	elif H=='2':\n		with M(D,n)as L:\n			F=L.read()\n			if not F:B.error(f"Input file '{D}' is empty.");return\n		try:\n			R,U=T.decompress_with_best_method(F)\n			if R is C:return\n			W=I.path.splitext(D)[1].lower()\n			if J in[O.JPEG,O.TEXT]and not E.endswith((e,o,f)):\n				if W in[e,o]:E+=e\n				elif W==f:E+=f\n			with M(E,m)as P:P.write(R)\n			G=I.path.getsize(D);Y=I.path.getsize(E)if I.path.exists(E)else A(R);B.info(f"Decompression successful. Output saved to {E}.");B.info(f"Compressed: {G} bytes, Decompressed: {Y} bytes")\n			if U:B.info(f"Restored Creation Date: {U.strftime("%Y-%m-%d %H:%M:%S")}")\n		except K as Z:B.error(f"Error during decompression: {Z}")\nif __name__=='__main__':A5()\n""")
